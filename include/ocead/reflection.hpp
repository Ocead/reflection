/// \mainpage  A single-include library for reflection in C++ programs
/// <pre style="line-height:1.0">
///                                                ██
///                                                ██
///                                                ██
///                                                ██
///                        ██      ██  ██  ██  ██  ██
///                        ██      ██  ██  ██  ██  ██
///                        ██      ██      ██  ██  ██
///                        ██      ██  ██████  ██  ██
///                        ██      ██          ██  ██
///                        ██      ██  ██  ██  ██  ██
///                        ██      ██  ██  ██  ██  ██
///                                            ██  ██
///                                            ██  ██
/// </pre>
///
/// This library allows you to write and use reflective classes in C++
/// ##Features
/// + Support for writing reflective classes
/// + Accessing member fields and functions through reflectors
/// + Templates for record classes
///
/// See the README.md file from this file's git repository
///
/// \author Johannes Milczewski
/// \copyright
/// \parblock
/// <pre>
/// Copyright Johannes Milczewski 2020 - 2021.
/// Distributed under the Boost Software License Version 1.0.
///
/// Permission is hereby granted, free of charge, to any person or organization
/// obtaining a copy of the software and accompanying documentation covered by
/// this license (the "Software") to use, reproduce, display, distribute,
/// execute, and transmit the Software, and to prepare derivative works of the
/// Software, and to permit third-parties to whom the Software is furnished to
/// do so, all subject to the following:
///
/// The copyright notices in the Software and this entire statement, including
/// the above license grant, this restriction and the following disclaimer,
/// must be included in all copies of the Software, in whole or in part, and
/// all derivative works of the Software, unless such copies or derivative
/// works are solely in the form of machine-executable object code generated by
/// a source language processor.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
/// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
/// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
/// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
/// </pre>
/// \endparblock
/// \version 1.0

#ifndef OCEAD_REFLECTION_HPP
#define OCEAD_REFLECTION_HPP

/// \defgroup reflection Reflection
/// \brief Everything needed for writing reflective classes

/// \defgroup options Options
/// \brief Macros for configuring this header

/// \defgroup reflector Reflectors
/// \brief Symbols for working with reflective classes

/// \defgroup record Records
/// \brief Symbols for working with records

#include <cassert>
#include <functional>
#include <iostream>
#include <type_traits>

//region Reflection options

#ifdef _DOXYGEN_
/// \brief Disables reflection if defined
/// \ingroup options
#define OCEAD_NO_REFLECTION
#endif

#ifndef OCEAD_REFLECTION_COUNTER_TYPE
#include <cstddef>
/// \brief A constexpr type
/// that can store program-wide unique IDs for reflective symbols
///
/// Default is <code>std::size_t</code>
/// \ingroup options
#define OCEAD_REFLECTION_COUNTER_TYPE std::size_t
#endif

#ifndef OCEAD_REFLECTION_ID_TYPE
#include <cstddef>
/// \brief A constexpr type
/// that can store class-wide unique IDs for reflective symbols
///
/// Default is <code>std::size_t</code>
/// \ingroup options
#define OCEAD_REFLECTION_ID_TYPE std::size_t
#endif

#ifndef OCEAD_REFLECTION_TYPEID_TYPE
#include <cstddef>
/// \brief A constexpr type
/// that can store unique hashes or descriptors for C/C++ types
///
/// Default is <code>char const *</code>
/// \ingroup options
#define OCEAD_REFLECTION_TYPEID_TYPE char const *
#endif

#ifndef OCEAD_REFLECTION_IDENTIFIER_MACRO
/// \brief Macro for obtaining a unique hash or descriptor for C/C++ types
/// \param type A valid C/C++ typename
///
/// Default is <code>ocead::reflection::typename_hash(#type)</code>
/// \ingroup options
#define OCEAD_REFLECTION_IDENTIFIER_MACRO(type) #type
#endif

#ifndef OCEAD_REFLECTION_NAME_TYPE
/// \brief A constexpr type
/// that can store the names of reflective symbols
///
/// Default is <code>char const *</code>
/// \ingroup options
#define OCEAD_REFLECTION_NAME_TYPE char const *
#endif

#ifndef OCEAD_REFLECTION_CONTAINER_TEMPLATE
/// \brief Macro for modifying the type of reflective symbols
///
/// Default is <code>ocead::reflection::type_identity</code>
/// \ingroup options
#define OCEAD_REFLECTION_CONTAINER_TEMPLATE ocead::reflection::type_identity
#endif

#ifndef OCEAD_REFLECTION_ACCESSOR_TYPE
/// \brief A C/C++ type that can hold pointers to accessor functions
///
/// Default is <code>ocead::reflection::accessor_t</code>
/// \ingroup options
#define OCEAD_REFLECTION_ACCESSOR_TYPE ocead::reflection::accessor_t
#endif

#ifndef OCEAD_REFLECTION_CONST_ACCESSOR_TYPE
/// \brief A C/C++ type that can hold pointers to const accessor functions
///
/// Default is <code>ocead::reflection::const_accessor_t</code>
/// \ingroup options
#define OCEAD_REFLECTION_CONST_ACCESSOR_TYPE ocead::reflection::const_accessor_t
#endif

#ifndef OCEAD_REFLECTION_INVOKER_TYPE
/// \brief A C/C++ type that can hold pointers to invoker functions
///
/// Default is <code>ocead::reflection::invoker_t</code>
/// \ingroup options
#define OCEAD_REFLECTION_INVOKER_TYPE ocead::reflection::invoker_t
#endif

#ifndef OCEAD_REFLECTION_CONST_INVOKER_TYPE
/// \brief A C/C++ type that can hold pointers to const invoker functions
///
/// Default is <code>ocead::reflection::invoker_t</code>
/// \ingroup options
#define OCEAD_REFLECTION_CONST_INVOKER_TYPE ocead::reflection::const_invoker_t
#endif

#ifndef OCEAD_REFLECTION_SHARED_PTR_TYPE
#include <memory>
/// \brief A C++ smart pointer type,
/// that stores the contained objects destructor function
///
/// Default is <code>std::shared_ptr&lt;void&gt;</code>
/// \ingroup options
#define OCEAD_REFLECTION_SHARED_PTR_TYPE std::shared_ptr<void>
#endif

#ifndef OCEAD_REFLECTION_SYMBOL_DESCRIPTOR_TYPE
/// \brief A type that describes single reflective symbols
///
/// Default is <code>ocead::reflection::symbol_descriptor</code>
/// \ingroup options
#define OCEAD_REFLECTION_SYMBOL_DESCRIPTOR_TYPE                                \
    ocead::reflection::symbol_descriptor
#endif

#ifndef OCEAD_REFLECTION_REFLECTOR_MAP_TYPE
#include <map>
#include <utility>
/// \brief A C++ template type that satisfies <i>AssociativeContainer</i>
///
/// Default is <code>std::map</code>
/// \ingroup options
#define OCEAD_REFLECTION_REFLECTOR_MAP_TYPE std::map
#endif

#ifndef OCEAD_REFLECTION_CLASS_DESCRIPTOR_TYPE
/// \brief A type that describes a reflective class
///
/// Default is <code>ocead::reflection::class_descriptor</code>
/// \ingroup options
#define OCEAD_REFLECTION_CLASS_DESCRIPTOR_TYPE                                 \
    ocead::reflection::class_descriptor
#endif

#ifndef OCEAD_REFLECTION_DEFAULT_PROPERTY_VISIBILITY
/// \brief The default visibility for reflective properties
///
/// Default is <code>private:</code>
/// \ingroup options
#define OCEAD_REFLECTION_DEFAULT_PROPERTY_VISIBILITY private:
#endif

#ifndef OCEAD_REFLECTION_DEFAULT_FUNCTION_VISIBILITY
/// \brief The default visibility for reflective function
///
/// Default is <code>public:</code>
/// \ingroup options
#define OCEAD_REFLECTION_DEFAULT_FUNCTION_VISIBILITY public:
#endif

#ifndef OCEAD_REFLECTION_DEFAULT_CONSTRUCTOR_VISIBILITY
/// \brief The default visibility for reflective constructor
///
/// Default is <code>public:</code>
/// \ingroup options
#define OCEAD_REFLECTION_DEFAULT_CONSTRUCTOR_VISIBILITY public:
#endif


#ifndef OCEAD_REFLECTION_DEFAULT_DESTRUCTOR_VISIBILITY
/// \brief The default visibility for reflective destructors
///
/// Default is <code>public:</code>
/// \ingroup options
#define OCEAD_REFLECTION_DEFAULT_DESTRUCTOR_VISIBILITY public:
#endif

#ifndef OCEAD_REFLECTION_ADD_PREFIX
/// \brief Macro that is applied to every additional symbol
/// this library declares in reflective classes
/// \param symbol Name to apply this macro on
///
/// Default is <code>_</code><code>reflection_##symbol</code>
/// \ingroup options
#define OCEAD_REFLECTION_ADD_PREFIX(symbol) _reflection_##symbol
#endif

//endregion

//region Record forwarding declarations

namespace ocead::reflection {
    template<typename RCTp, OCEAD_REFLECTION_ID_TYPE ID>
    struct record_piece;
}

//endregion

//region Reflection macros

//region Pre-symbol
#define OCEAD_REFLECTION_PRE_SYMBOL(prop_type, id, name, num)                  \
    template<typename _>                                                       \
    struct OCEAD_REFLECTION_ADD_PREFIX(property_id)<num, _> {                  \
        static constexpr OCEAD_REFLECTION_ID_TYPE value = id;                  \
    };                                                                         \
                                                                               \
    template<typename _>                                                       \
    struct OCEAD_REFLECTION_ADD_PREFIX(property_name)<num, _> {                \
        static constexpr OCEAD_REFLECTION_NAME_TYPE value = #name;             \
    };                                                                         \
                                                                               \
    template<typename _>                                                       \
    struct OCEAD_REFLECTION_ADD_PREFIX(type)<id, _> {                          \
        using type = prop_type;                                                \
    };                                                                         \
                                                                               \
    template<typename _>                                                       \
    struct OCEAD_REFLECTION_ADD_PREFIX(property_typeid)<num, _> {              \
        static constexpr OCEAD_REFLECTION_TYPEID_TYPE value =                  \
                OCEAD_REFLECTION_IDENTIFIER_MACRO(prop_type);                  \
    };
//endregion

//region Begin
#ifndef OCEAD_NO_REFLECTION
#define OCEAD_REFLECTION_BEGIN_REFLECTIVE(class_name)                          \
private:                                                                       \
    static constexpr OCEAD_REFLECTION_COUNTER_TYPE                             \
            OCEAD_REFLECTION_ADD_PREFIX(BEGIN_ID) = __COUNTER__ + 1;           \
                                                                               \
    using OCEAD_REFLECTION_ADD_PREFIX(class_type) = class_name;                \
                                                                               \
    template<OCEAD_REFLECTION_COUNTER_TYPE num, typename = void>               \
    struct OCEAD_REFLECTION_ADD_PREFIX(symbol_type) {};                        \
                                                                               \
    template<OCEAD_REFLECTION_ID_TYPE id, typename = void>                     \
    struct OCEAD_REFLECTION_ADD_PREFIX(type) {};                               \
                                                                               \
    template<OCEAD_REFLECTION_ID_TYPE id, typename = void>                     \
    using OCEAD_REFLECTION_ADD_PREFIX(type_t) =                                \
            typename OCEAD_REFLECTION_ADD_PREFIX(type)<id>::type;              \
                                                                               \
    template<OCEAD_REFLECTION_COUNTER_TYPE num, typename = void>               \
    struct OCEAD_REFLECTION_ADD_PREFIX(property_id) {};                        \
                                                                               \
    template<OCEAD_REFLECTION_COUNTER_TYPE num, typename = void>               \
    struct OCEAD_REFLECTION_ADD_PREFIX(property_name) {};                      \
                                                                               \
    template<OCEAD_REFLECTION_COUNTER_TYPE num, typename = void>               \
    struct OCEAD_REFLECTION_ADD_PREFIX(property_typeid) {};                    \
                                                                               \
    template<OCEAD_REFLECTION_COUNTER_TYPE num, typename = void>               \
    struct OCEAD_REFLECTION_ADD_PREFIX(property_accessor) {};                  \
                                                                               \
    template<OCEAD_REFLECTION_COUNTER_TYPE num, typename = void>               \
    struct OCEAD_REFLECTION_ADD_PREFIX(property_const_accessor) {};            \
                                                                               \
    template<OCEAD_REFLECTION_COUNTER_TYPE num, typename = void>               \
    struct OCEAD_REFLECTION_ADD_PREFIX(symbol_descriptor) {};                  \
                                                                               \
    template<OCEAD_REFLECTION_ID_TYPE id, typename = void>                     \
    struct OCEAD_REFLECTION_ADD_PREFIX(constructor) {                          \
        void *operator()(void *args) { return nullptr; }                       \
    };                                                                         \
                                                                               \
    template<OCEAD_REFLECTION_ID_TYPE id, typename = void>                     \
    struct OCEAD_REFLECTION_ADD_PREFIX(placement_constructor) {                \
        void *operator()(void *ptr, void *args) { return nullptr; }            \
    };                                                                         \
                                                                               \
    template<OCEAD_REFLECTION_ID_TYPE id, typename = void>                     \
    struct OCEAD_REFLECTION_ADD_PREFIX(shared_constructor) {                   \
        OCEAD_REFLECTION_SHARED_PTR_TYPE operator()(void *args) {              \
            return OCEAD_REFLECTION_SHARED_PTR_TYPE();                         \
        }                                                                      \
    };                                                                         \
                                                                               \
    template<OCEAD_REFLECTION_ID_TYPE id, typename = void>                     \
    struct OCEAD_REFLECTION_ADD_PREFIX(destructor) {                           \
        void operator()(void *ptr) {                                           \
            delete static_cast<OCEAD_REFLECTION_ADD_PREFIX(class_type) *>(     \
                    ptr);                                                      \
        }                                                                      \
    };                                                                         \
                                                                               \
    struct OCEAD_REFLECTION_ADD_PREFIX(deleter) {                              \
        void operator()(void *&ptr) {                                          \
            delete static_cast<OCEAD_REFLECTION_ADD_PREFIX(class_type) *>(     \
                    ptr);                                                      \
            ptr = nullptr;                                                     \
        }                                                                      \
    };                                                                         \
                                                                               \
    static void OCEAD_REFLECTION_ADD_PREFIX(delete)(void *&ptr) {              \
        return OCEAD_REFLECTION_ADD_PREFIX(deleter)()(ptr);                    \
    }                                                                          \
                                                                               \
    template<OCEAD_REFLECTION_COUNTER_TYPE num, typename = void>               \
    struct OCEAD_REFLECTION_ADD_PREFIX(signature_info) {};                     \
                                                                               \
    template<OCEAD_REFLECTION_ID_TYPE ID, typename = void>                     \
    struct OCEAD_REFLECTION_ADD_PREFIX(static_accessor);                       \
                                                                               \
    template<OCEAD_REFLECTION_ID_TYPE ID>                                      \
            auto OCEAD_REFLECTION_ADD_PREFIX(static_access)()                  \
                    const->std::add_lvalue_reference_t<std::add_const_t<       \
                            typename OCEAD_REFLECTION_ADD_PREFIX(type) < ID,   \
                            void>::type> > {                                   \
        return OCEAD_REFLECTION_ADD_PREFIX(static_accessor)<ID, void>()(       \
                *this);                                                        \
    }
#else
#define OCEAD_REFLECTION_NOTHING
#define OCEAD_REFLECTION_BEGIN_REFLECTIVE(...) OCEAD_REFLECTION_NOTHING
#endif
//endregion

//region Property
#ifndef OCEAD_NO_REFLECTION
#define OCEAD_REFLECTION_PROPERTY_DETAIL(access, prop_type, id, name, num)     \
private:                                                                       \
    template<typename _>                                                       \
    struct OCEAD_REFLECTION_ADD_PREFIX(symbol_type)<num, _> {                  \
        static constexpr auto value = ocead::reflection::symbol_t(             \
                ocead::reflection::symbol_t::SYMBOL_PROPERTY |                 \
                (std::is_const_v<prop_type>                                    \
                         ? ocead::reflection::symbol_t::SYMBOL_CONST           \
                         : ocead::reflection::symbol_t()) |                    \
                (std::is_reference_v<prop_type>                                \
                         ? ocead::reflection::symbol_t::SYMBOL_REFERENCE       \
                         : ocead::reflection::symbol_t()));                    \
    };                                                                         \
                                                                               \
    OCEAD_REFLECTION_PRE_SYMBOL(prop_type, id, name, num)                      \
                                                                               \
                                                                               \
private:                                                                       \
    static void *OCEAD_REFLECTION_ADD_PREFIX(access_##name)(void *ptr) {       \
        if constexpr (std::is_const_v<decltype(name)>) {                       \
            return nullptr;                                                    \
        } else {                                                               \
            using unconst = std::remove_const_t<decltype(name)>;               \
            return &const_cast<unconst &>(                                     \
                    static_cast<OCEAD_REFLECTION_ADD_PREFIX(class_type) *>(    \
                            ptr)                                               \
                            ->name);                                           \
        }                                                                      \
    }                                                                          \
                                                                               \
    static void const *OCEAD_REFLECTION_ADD_PREFIX(access_##name##_const)(     \
            void const *ptr) {                                                 \
        return &static_cast<OCEAD_REFLECTION_ADD_PREFIX(class_type) const *>(  \
                        ptr)                                                   \
                        ->name;                                                \
    }                                                                          \
                                                                               \
    template<typename _>                                                       \
    struct OCEAD_REFLECTION_ADD_PREFIX(property_accessor)<num, _> {            \
        static constexpr OCEAD_REFLECTION_ACCESSOR_TYPE value =                \
                (OCEAD_REFLECTION_ACCESSOR_TYPE) &OCEAD_REFLECTION_ADD_PREFIX( \
                        class_type)::                                          \
                        OCEAD_REFLECTION_ADD_PREFIX(access_##name);            \
    };                                                                         \
                                                                               \
    template<typename _>                                                       \
    struct OCEAD_REFLECTION_ADD_PREFIX(property_const_accessor)<num, _> {      \
        static constexpr OCEAD_REFLECTION_CONST_ACCESSOR_TYPE value =          \
                &OCEAD_REFLECTION_ADD_PREFIX(class_type)::                     \
                        OCEAD_REFLECTION_ADD_PREFIX(access_##name##_const);    \
    };                                                                         \
                                                                               \
    template<typename _>                                                       \
    struct OCEAD_REFLECTION_ADD_PREFIX(symbol_descriptor)<num, _> {            \
        static constexpr OCEAD_REFLECTION_SYMBOL_DESCRIPTOR_TYPE value =       \
                OCEAD_REFLECTION_SYMBOL_DESCRIPTOR_TYPE{                       \
                        num,                                                   \
                        OCEAD_REFLECTION_ADD_PREFIX(symbol_type) < num >       \
                                ::value,                                       \
                        OCEAD_REFLECTION_ADD_PREFIX(property_id) < num >       \
                                ::value,                                       \
                        OCEAD_REFLECTION_ADD_PREFIX(property_typeid) < num >   \
                                ::value,                                       \
                        OCEAD_REFLECTION_ADD_PREFIX(property_name) < num >     \
                                ::value,                                       \
                        OCEAD_REFLECTION_ADD_PREFIX(property_accessor) < num > \
                                ::value,                                       \
                        OCEAD_REFLECTION_ADD_PREFIX(property_const_accessor) < \
                                num > ::value};                                \
    };                                                                         \
                                                                               \
    template<typename _>                                                       \
    struct OCEAD_REFLECTION_ADD_PREFIX(static_accessor)<id, _> {               \
        auto &operator()(OCEAD_REFLECTION_ADD_PREFIX(class_type) const &ref) { \
            return ref.name;                                                   \
        };                                                                     \
    };                                                                         \
                                                                               \
    access alignas(std::max(alignof(prop_type), std::size_t(1)))               \
            OCEAD_REFLECTION_CONTAINER_TEMPLATE<prop_type>::type name
#else
#define OCEAD_REFLECTION_PROPERTY_DETAIL(access, prop_type, id, name, num)     \
    access prop_type name
#endif

#define OCEAD_REFLECTION_DEFAULT_VISIBLE_PROPERTY(type, id, name, num)         \
    OCEAD_REFLECTION_PROPERTY_DETAIL(                                          \
            OCEAD_REFLECTION_DEFAULT_PROPERTY_VISIBILITY, type, id, name, num)


#define OCEAD_REFLECTION_GET_PROPERTY_MACRO(_1, _2, _3, _4, _5, NAME, ...) NAME


#define OCEAD_REFLECTION_PROPERTY(...)                                         \
    OCEAD_REFLECTION_GET_PROPERTY_MACRO(                                       \
            __VA_ARGS__, OCEAD_REFLECTION_PROPERTY_DETAIL,                     \
            OCEAD_REFLECTION_DEFAULT_VISIBLE_PROPERTY, UNUSED, UNUSED,         \
            UNSUSED)                                                           \
    (__VA_ARGS__)
//endregion

//region Function
#ifndef OCEAD_NO_REFLECTION
#define OCEAD_REFLECTION_FUNCTION_DETAIL(access, prop_type, id, name, sig,     \
                                         num)                                  \
                                                                               \
private:                                                                       \
    template<typename _>                                                       \
    struct OCEAD_REFLECTION_ADD_PREFIX(signature_info)<num, _> {               \
        using type = ocead::typing::signature_info<prop_type(                  \
                OCEAD_REFLECTION_ADD_PREFIX(class_type)::*) sig>;              \
    };                                                                         \
                                                                               \
private:                                                                       \
    template<typename _>                                                       \
    struct OCEAD_REFLECTION_ADD_PREFIX(symbol_type)<num, _> {                  \
        static constexpr ocead::reflection::symbol_t value =                   \
                ocead::reflection::symbol_t(                                   \
                        ocead::reflection::symbol_t::SYMBOL_FUNCTION |         \
                        (std::is_const_v<typename OCEAD_REFLECTION_ADD_PREFIX( \
                                                 signature_info) < num,        \
                                         _>::type::class_type >                \
                                 ? ocead::reflection::symbol_t::SYMBOL_CONST   \
                                 : ocead::reflection::symbol_t()));            \
    };                                                                         \
                                                                               \
    OCEAD_REFLECTION_PRE_SYMBOL(prop_type, id, name, num)                      \
                                                                               \
    static void OCEAD_REFLECTION_ADD_PREFIX(invoke_##name##_##num)(            \
            void *_ret,                                                        \
            std::conditional_t<std::is_const_v<OCEAD_REFLECTION_ADD_PREFIX(    \
                                                       signature_info) < num,  \
                                               void>::type::class_type>,       \
            void const *, void * > _obj, void *_args) {                        \
        using signature_info =                                                 \
                OCEAD_REFLECTION_ADD_PREFIX(signature_info<num>)::type;        \
        using RTp = signature_info::return_type;                               \
        using PRTp = ocead::typing::simplify<RTp>::type;                       \
        auto &obj = *static_cast<signature_info::class_type *>(_obj);          \
        auto &args = *static_cast<signature_info::arguments_type *>(_args);    \
        auto fun = static_cast<signature_info::ptr_type>(                      \
                &OCEAD_REFLECTION_ADD_PREFIX(class_type)::name);               \
        if (_ret) {                                                            \
            auto *ret = static_cast<PRTp *>(_ret);                             \
            new (ret) PRTp(ocead::typing::simplify<RTp>()(                     \
                    ocead::typing::apply_return<int>(                          \
                            fun,                                               \
                            std::tuple_cat(std::make_tuple(std::ref(obj)),     \
                                           args))));                           \
        } else {                                                               \
            ocead::typing::apply_return<int>(                                  \
                    fun,                                                       \
                    std::tuple_cat(std::make_tuple(std::ref(obj)), args));     \
        }                                                                      \
    }                                                                          \
                                                                               \
    template<typename _>                                                       \
    struct OCEAD_REFLECTION_ADD_PREFIX(symbol_descriptor)<num, _> {            \
        static constexpr OCEAD_REFLECTION_SYMBOL_DESCRIPTOR_TYPE value =       \
                OCEAD_REFLECTION_SYMBOL_DESCRIPTOR_TYPE{                       \
                        num,                                                   \
                        OCEAD_REFLECTION_ADD_PREFIX(symbol_type) < num >       \
                                ::value,                                       \
                        OCEAD_REFLECTION_ADD_PREFIX(property_id) < num >       \
                                ::value,                                       \
                        OCEAD_REFLECTION_ADD_PREFIX(property_typeid) < num >   \
                                ::value,                                       \
                        OCEAD_REFLECTION_ADD_PREFIX(property_name) < num >     \
                                ::value,                                       \
                        OCEAD_REFLECTION_ADD_PREFIX(invoke_##name##_##num)};   \
    };                                                                         \
                                                                               \
    access prop_type name sig
#else
#define OCEAD_REFLECTION_FUNCTION_DETAIL(access, prop_type, id, name, sig,     \
                                         num)                                  \
    access prop_type name sig
#endif

#define OCEAD_REFLECTION_DEFAULT_VISIBLE_FUNCTION(type, id, name, sig, num)    \
    OCEAD_REFLECTION_FUNCTION_DETAIL(                                          \
            OCEAD_REFLECTION_DEFAULT_FUNCTION_VISIBILITY, type, id, name, sig, \
            num)


#define OCEAD_REFLECTION_GET_FUNCTION_MACRO(_1, _2, _3, _4, _5, _6, NAME, ...) \
    NAME


#define OCEAD_REFLECTION_FUNCTION(...)                                         \
    OCEAD_REFLECTION_GET_FUNCTION_MACRO(                                       \
            __VA_ARGS__, OCEAD_REFLECTION_FUNCTION_DETAIL,                     \
            OCEAD_REFLECTION_DEFAULT_VISIBLE_FUNCTION, UNUSED, UNUSED, UNUSED, \
            UNUSED)                                                            \
    (__VA_ARGS__)
//endregion

//region Constructor
#ifndef OCEAD_NO_REFLECTION
#define OCEAD_REFLECTION_CONSTRUCTOR_DETAIL(access, id, name, sig, num)        \
private:                                                                       \
    template<typename _>                                                       \
    struct OCEAD_REFLECTION_ADD_PREFIX(symbol_type)<num, _> {                  \
        static constexpr ocead::reflection::symbol_t value =                   \
                ocead::reflection::symbol_t::SYMBOL_CONSTRUCTOR;               \
    };                                                                         \
                                                                               \
    OCEAD_REFLECTION_PRE_SYMBOL(name, id, name, num)                           \
                                                                               \
    template<typename _>                                                       \
    struct OCEAD_REFLECTION_ADD_PREFIX(constructor)<id, _> {                   \
        void *operator()(void *args) {                                         \
            using Args = ocead::typing::signature_info<                        \
                    std::function<void sig>>::arguments_type;                  \
            return ocead::make_new_from_tuple<name>(                           \
                    *static_cast<Args *>(args));                               \
        }                                                                      \
    };                                                                         \
                                                                               \
    static void *OCEAD_REFLECTION_ADD_PREFIX(construct_##num)(void *args) {    \
        return OCEAD_REFLECTION_ADD_PREFIX(constructor<id>)()(args);           \
    }                                                                          \
                                                                               \
    template<typename _>                                                       \
    struct OCEAD_REFLECTION_ADD_PREFIX(placement_constructor)<id, _> {         \
        void *operator()(void *ptr, void *args) {                              \
            using Args = ocead::typing::signature_info<                        \
                    std::function<void sig>>::arguments_type;                  \
            return ocead ::make_new_from_tuple<name>(                          \
                    static_cast<name *>(ptr), *static_cast<Args *>(args));     \
        }                                                                      \
    };                                                                         \
                                                                               \
    static void *OCEAD_REFLECTION_ADD_PREFIX(placement_construct_##num)(       \
            void *ptr, void *args) {                                           \
        return OCEAD_REFLECTION_ADD_PREFIX(placement_constructor<id>)()(ptr,   \
                                                                        args); \
    }                                                                          \
                                                                               \
    template<typename _>                                                       \
    struct OCEAD_REFLECTION_ADD_PREFIX(shared_constructor)<id, _> {            \
        OCEAD_REFLECTION_SHARED_PTR_TYPE operator()(void *args) {              \
            using Deleter = OCEAD_REFLECTION_ADD_PREFIX(deleter);              \
            auto *ptr = OCEAD_REFLECTION_ADD_PREFIX(constructor<id>)()(args);  \
            return std::shared_ptr<void>(ptr, Deleter());                      \
        }                                                                      \
    };                                                                         \
                                                                               \
    static OCEAD_REFLECTION_SHARED_PTR_TYPE OCEAD_REFLECTION_ADD_PREFIX(       \
            shared_construct_##num)(void *args) {                              \
        return OCEAD_REFLECTION_ADD_PREFIX(shared_constructor<id>)()(args);    \
    }                                                                          \
                                                                               \
    template<typename _>                                                       \
    struct OCEAD_REFLECTION_ADD_PREFIX(symbol_descriptor)<num, _> {            \
        static constexpr OCEAD_REFLECTION_SYMBOL_DESCRIPTOR_TYPE value =       \
                OCEAD_REFLECTION_SYMBOL_DESCRIPTOR_TYPE{                       \
                        num,                                                   \
                        OCEAD_REFLECTION_ADD_PREFIX(symbol_type) < num >       \
                                ::value,                                       \
                        OCEAD_REFLECTION_ADD_PREFIX(property_id) < num >       \
                                ::value,                                       \
                        OCEAD_REFLECTION_ADD_PREFIX(property_typeid) < num >   \
                                ::value,                                       \
                        OCEAD_REFLECTION_ADD_PREFIX(property_name) < num >     \
                                ::value,                                       \
                        OCEAD_REFLECTION_ADD_PREFIX(construct_##num),          \
                        OCEAD_REFLECTION_ADD_PREFIX(                           \
                                placement_construct_##num),                    \
                        OCEAD_REFLECTION_ADD_PREFIX(shared_construct_##num)};  \
    };                                                                         \
                                                                               \
    access name sig
#else
#define OCEAD_REFLECTION_CONSTRUCTOR_DETAIL(access, id, name, sig, num)        \
    access name sig
#endif

#define OCEAD_REFLECTION_DEFAULT_VISIBLE_CONSTRUCTOR(id, name, sig, num)       \
    OCEAD_REFLECTION_CONSTRUCTOR_DETAIL(                                       \
            OCEAD_REFLECTION_DEFAULT_CONSTRUCTOR_VISIBILITY, id, name, sig,    \
            num)


#define OCEAD_REFLECTION_GET_CONSTRUCTOR_MACRO(_1, _2, _3, _4, _5, NAME, ...)  \
    NAME


#define OCEAD_REFLECTION_CONSTRUCTOR(...)                                      \
    OCEAD_REFLECTION_GET_CONSTRUCTOR_MACRO(                                    \
            __VA_ARGS__, OCEAD_REFLECTION_CONSTRUCTOR_DETAIL,                  \
            OCEAD_REFLECTION_DEFAULT_VISIBLE_CONSTRUCTOR, UNUSED, UNUSED,      \
            UNUSED)                                                            \
    (__VA_ARGS__)
//endregion

//region Destructor
#ifndef OCEAD_NO_REFLECTION
#define OCEAD_REFLECTION_DESTRUCTOR_DETAIL(access, id, name, num)              \
private:                                                                       \
    template<typename _>                                                       \
    struct OCEAD_REFLECTION_ADD_PREFIX(symbol_type)<num, _> {                  \
        static constexpr ocead::reflection::symbol_t value =                   \
                ocead::reflection::symbol_t::SYMBOL_DESTRUCTOR;                \
    };                                                                         \
                                                                               \
    OCEAD_REFLECTION_PRE_SYMBOL(name, id, name, num)                           \
                                                                               \
    template<typename _>                                                       \
    struct OCEAD_REFLECTION_ADD_PREFIX(destructor)<id, _> {                    \
        void operator()(void *ptr) {                                           \
            static_cast<OCEAD_REFLECTION_ADD_PREFIX(class_type) *>(ptr)        \
                    ->~name();                                                 \
        }                                                                      \
    };                                                                         \
                                                                               \
    static void OCEAD_REFLECTION_ADD_PREFIX(destroy_##num)(void *ptr) {        \
        return OCEAD_REFLECTION_ADD_PREFIX(destructor<id>)()(ptr);             \
    }                                                                          \
                                                                               \
    template<typename _>                                                       \
    struct OCEAD_REFLECTION_ADD_PREFIX(symbol_descriptor)<num, _> {            \
        static constexpr OCEAD_REFLECTION_SYMBOL_DESCRIPTOR_TYPE value =       \
                OCEAD_REFLECTION_SYMBOL_DESCRIPTOR_TYPE{                       \
                        num,                                                   \
                        OCEAD_REFLECTION_ADD_PREFIX(symbol_type) < num >       \
                                ::value,                                       \
                        OCEAD_REFLECTION_ADD_PREFIX(property_id) < num >       \
                                ::value,                                       \
                        OCEAD_REFLECTION_ADD_PREFIX(property_typeid) < num >   \
                                ::value,                                       \
                        OCEAD_REFLECTION_ADD_PREFIX(property_name) < num >     \
                                ::value,                                       \
                        OCEAD_REFLECTION_ADD_PREFIX(destroy_##num),            \
                        OCEAD_REFLECTION_ADD_PREFIX(delete)};                  \
    };                                                                         \
                                                                               \
    access ~name()
#else
#define OCEAD_REFLECTION_DESTRUCTOR_DETAIL(access, id, name, num) access ~name()
#endif

#define OCEAD_REFLECTION_DEFAULT_VISIBLE_DESTRUCTOR(id, name, num)             \
    OCEAD_REFLECTION_DESTRUCTOR_DETAIL(                                        \
            OCEAD_REFLECTION_DEFAULT_DESTRUCTOR_VISIBILITY, id, name, num)


#define OCEAD_REFLECTION_GET_DESTRUCTOR_MACRO(_1, _2, _3, _4, NAME, ...) NAME


#define OCEAD_REFLECTION_DESTRUCTOR(...)                                       \
    OCEAD_REFLECTION_GET_DESTRUCTOR_MACRO(                                     \
            __VA_ARGS__, OCEAD_REFLECTION_DESTRUCTOR_DETAIL,                   \
            OCEAD_REFLECTION_DEFAULT_VISIBLE_DESTRUCTOR, UNUSED, UNUSED)       \
    (__VA_ARGS__)
//endregion

//region End
#ifdef __cpp_rtti
#define OCEAD_REFLECTION_RTTI_REFLECTOR                                        \
public:                                                                        \
    const OCEAD_REFLECTION_CLASS_DESCRIPTOR_TYPE &reflect() const override {   \
        static const OCEAD_REFLECTION_CLASS_DESCRIPTOR_TYPE refl{              \
                OCEAD_REFLECTION_CLASS_DESCRIPTOR_TYPE ::reflect<              \
                        OCEAD_REFLECTION_ADD_PREFIX(class_type)>()};           \
        return refl;                                                           \
    }
#else
#define OCEAD_REFLECTION_RTTI_REFLECTOR
#endif

#ifndef OCEAD_NO_REFLECTION
#define OCEAD_REFLECTION_END_REFLECTIVE()                                      \
private:                                                                       \
    static constexpr OCEAD_REFLECTION_COUNTER_TYPE                             \
            OCEAD_REFLECTION_ADD_PREFIX(END_ID) = __COUNTER__;                 \
                                                                               \
    static OCEAD_REFLECTION_COUNTER_TYPE OCEAD_REFLECTION_ADD_PREFIX(          \
            property_count)() {                                                \
        return OCEAD_REFLECTION_ADD_PREFIX(END_ID) -                           \
               OCEAD_REFLECTION_ADD_PREFIX(BEGIN_ID);                          \
    }                                                                          \
                                                                               \
    static const OCEAD_REFLECTION_CLASS_DESCRIPTOR_TYPE &                      \
    OCEAD_REFLECTION_ADD_PREFIX(class_descriptor)() {                          \
        static const OCEAD_REFLECTION_CLASS_DESCRIPTOR_TYPE refl{              \
                OCEAD_REFLECTION_CLASS_DESCRIPTOR_TYPE::reflect<               \
                        OCEAD_REFLECTION_ADD_PREFIX(class_type)>()};           \
        return refl;                                                           \
    }                                                                          \
                                                                               \
    OCEAD_REFLECTION_RTTI_REFLECTOR                                            \
                                                                               \
    friend struct ocead::reflection::symbol_descriptor;                        \
    friend class ocead::reflection::class_descriptor;                          \
    friend const OCEAD_REFLECTION_CLASS_DESCRIPTOR_TYPE &                      \
    ocead::reflection::reflect<OCEAD_REFLECTION_ADD_PREFIX(class_type)>();     \
    template<typename CTp, OCEAD_REFLECTION_ID_TYPE ID>                        \
    friend struct ocead::reflection::record_piece
#else
#define OCEAD_REFLECTION_END_REFLECTIVE()
#endif
//endregion

//endregion

//region Static for
#ifndef OCEAD_STATIC_FOR_HPP
#define OCEAD_STATIC_FOR_HPP

#include <utility>

namespace ocead {

    namespace detail {
        template<typename I, I Start, I End, template<I> class Func,
                 typename... Args>
        struct static_for_inner {
            constexpr void operator()(Args &&...args) {
                Func<Start>()(args...);
                static_for_inner<I, Start + 1, End, Func, Args...>()(
                        std::forward<Args>(args)...);
            }
        };

        template<typename I, I End, template<I> class Func, typename... Args>
        struct static_for_inner<I, End, End, Func, Args...> {
            constexpr void operator()(Args &&...) {}
        };
    }// namespace detail

    /// \brief Produces a compile-time loop over a range of incrementable values
    /// \tparam I Incrementing type
    /// \tparam Start Start value
    /// \tparam End End value
    /// \tparam Func Function type to call in the loop
    /// \tparam Args Argument types to call <code>Func</code> with
    /// \param args Argument to call <code>Func</code> with
    template<typename I, I Start, I End, template<I> class Func,
             typename... Args>
    constexpr void static_for(Args... args) {
        static_assert(Start <= End, "Start must be less than or equal to End");
        detail::static_for_inner<I, Start, End, Func, Args &&...>()(
                std::forward<Args>(args)...);
    }

};// namespace ocead

#endif//OCEAD_STATIC_FOR_HPP
//endregion

//region Reflection structures

namespace ocead {

    /// \brief Converts enum values into the corresponding underlying values,
    /// returns non-enum values as is
    /// \tparam ETp Maybe-enum type
    /// \param val Value to maybe convert
    /// \return The underlying value
    template<typename ETp,
             std::enable_if_t<!std::is_enum_v<ETp>, void *> = nullptr>
    constexpr ETp underlying(ETp val) {
        return val;
    }

    /// \brief Converts enum values into the corresponding underlying values,
    /// returns non-enum values as is
    /// \tparam ETp Maybe-enum type
    /// \param val Value to maybe convert
    /// \return The underlying value
    template<typename ETp,
             std::enable_if_t<std::is_enum_v<ETp>, void *> = nullptr>
    constexpr auto underlying(ETp const &val) ->
            typename std::underlying_type<ETp>::type {
        return typename std::underlying_type<ETp>::type(val);
    }

    /// \brief Converts enum values into the corresponding underlying values,
    /// returns non-enum values as is
    /// \tparam ETp Maybe-enum type
    /// \param val Value to maybe convert
    /// \return The underlying value
    template<typename ETp,
             std::enable_if_t<std::is_enum_v<ETp>, void *> = nullptr>
    constexpr auto underlying(ETp &&val) ->
            typename std::underlying_type<ETp>::type {
        return typename std::underlying_type<ETp>::type(val);
    }

    namespace detail {
        template<class T, class Tuple, std::size_t... I>
        constexpr T *make_new_from_tuple_impl(T *ptr, Tuple &&t,
                                              std::index_sequence<I...>) {
            return new (ptr) T(std::get<I>(std::forward<Tuple>(t))...);
        }

        template<class T, class Tuple, std::size_t... I>
        constexpr T *make_new_from_tuple_impl(Tuple &&t,
                                              std::index_sequence<I...>) {
            return new T(std::get<I>(std::forward<Tuple>(t))...);
        }
    }// namespace detail

    /// \brief Constructs an instance of <code>T</code>
    /// from a tuple of arguments with placement <code>new</code>
    /// \tparam T Type
    /// \tparam Tuple Arguments tuple type
    /// \param ptr Address where the instance shall be constructed
    /// \param t Arguments
    /// \return Pointer to the created instance
    template<typename T, typename Tuple>
    constexpr T *make_new_from_tuple(T *ptr, Tuple &&t) {
        return detail::make_new_from_tuple_impl<T>(
                ptr, std::forward<Tuple>(t),
                std::make_index_sequence<
                        std::tuple_size_v<std::remove_reference_t<Tuple>>>{});
    }

    /// \brief Constructs an instance of <code>T</code>
    /// from a tuple of arguments with <code>new</code>
    /// \tparam T Type
    /// \tparam Tuple Arguments tuple type
    /// \param t Arguments
    /// \return Pointer to the created instance
    template<typename T, typename Tuple>
    constexpr T *make_new_from_tuple(Tuple &&t) {
        return detail::make_new_from_tuple_impl<T>(
                std::forward<Tuple>(t),
                std::make_index_sequence<
                        std::tuple_size_v<std::remove_reference_t<Tuple>>>{});
    }

    namespace typing {

        /// \brief Checks if a function returns void
        /// \tparam FTp Function type
        /// \tparam Args Argument types
        template<typename FTp, typename... Args>
        struct returns_void {
            static constexpr bool value =
                    std::is_void_v<std::invoke_result_t<FTp, Args...>>;
        };

        /// \brief Checks if a function returns void
        /// \tparam FTp Function type
        /// \tparam Args Argument types
        template<typename FTp, typename... Args>
        constexpr auto returns_void_v = returns_void<FTp, Args...>::value;

        /// \brief Variant of <code>std::apply</code>
        /// that always returns a value
        /// \tparam RTp Return type, if <code>FTp(Args ...)</code>
        /// returns <code>void</code>
        /// \tparam FTp Function type
        /// \tparam Args Argument types
        /// \param fun Function pointer to call
        /// \param args Arguments, with which the function is called
        /// \return <code>RTp{}</code> if <code>FTp(Args ...)</code> returns
        /// void, otherwise the value returned by <code>FTp(Args ...)</code>
        template<typename RTp, typename FTp, typename... Args,
                 std::enable_if_t<returns_void_v<FTp, Args...>, void *> =
                         nullptr>
        auto apply_return(FTp &&fun, std::tuple<Args...> &&args) {
            std::apply<FTp, std::tuple<Args...>>(
                    fun, std::forward<std::tuple<Args...>>(args));
            return RTp();
        }

        /// \brief Variant of <code>std::apply</code>
        /// that always returns a value
        /// \tparam RTp Return type, if <code>FTp(Args ...)</code>
        /// returns <code>void</code>
        /// \tparam FTp Function type
        /// \tparam Args Argument types
        /// \param fun Function pointer to call
        /// \param args Arguments, with which the function is called
        /// \return <code>RTp{}</code> if <code>FTp(Args ...)</code> returns
        /// void, otherwise the value returned by <code>FTp(Args ...)</code>
        template<typename RTp, typename FTp, typename... Args,
                 std::enable_if_t<!returns_void_v<FTp, Args...>, void *> =
                         nullptr>
        auto apply_return(FTp &&fun, std::tuple<Args...> &&args) {
            return std::apply<FTp, std::tuple<Args...>>(
                    fun, std::forward<std::tuple<Args...>>(args));
        }

        template<typename...>
        struct signature_info {};

        template<typename RTp, typename... Args>
        struct signature_info<RTp (*)(Args...)> {
            using ptr_type = RTp (*)(Args...);
            using fun_type = std::function<RTp(Args...)>;
            using return_type = RTp;
            using always_return_type =
                    std::conditional<std::is_void<RTp>::value, int, RTp>;
            using class_type = void;
            using arguments_type = std::tuple<Args...>;
            static constexpr auto arguments_count = sizeof...(Args);
        };

        template<typename RTp, typename CTp, typename... Args>
        struct signature_info<RTp (CTp::*)(Args...)> {
            using ptr_type = RTp (CTp::*)(Args...);
            using fun_type = std::function<RTp(Args...)>;
            using return_type = RTp;
            using always_return_type =
                    std::conditional<std::is_void<RTp>::value, int, RTp>;
            using class_type = CTp;
            using arguments_type = std::tuple<Args...>;
            static constexpr auto arguments_count = sizeof...(Args);
        };

        template<typename RTp, typename CTp, typename... Args>
        struct signature_info<RTp (CTp::*)(Args...) const> {
            using ptr_type = RTp (CTp::*)(Args...) const;
            using fun_type = std::function<RTp(Args...)>;
            using return_type = RTp;
            using always_return_type =
                    std::conditional<std::is_void<RTp>::value, int, RTp>;
            using class_type = const CTp;
            using arguments_type = std::tuple<Args...>;
            static constexpr auto arguments_count = sizeof...(Args);
        };

        template<typename RTp, typename... Args>
        struct signature_info<std::function<RTp(Args...)>> {
            using ptr_type = RTp (*)(Args...);
            using fun_type = std::function<RTp(Args...)>;
            using return_type = RTp;
            using always_return_type =
                    std::conditional<std::is_void<RTp>::value, int, RTp>;
            using class_type = void;
            using arguments_type = std::tuple<Args...>;
            static constexpr auto arguments_count = sizeof...(Args);
        };

        template<typename T>
        struct simplify {
            using type = T;
            T operator()(T &&fref) { return std::forward<T>(fref); }
        };

        template<typename T>
        struct simplify<T &> {
            using type = T *;
            T *operator()(T &ref) { return &ref; }
        };

        template<typename T>
        struct simplify<const T &> {
            using type = T const *;
            T const *operator()(T const &ref) { return &ref; }
        };

        template<>
        struct simplify<void> {
            using type = int;
            template<typename T>
            int operator()(T) {
                return 0;
            }
        };

        template<typename R, typename T>
        struct restore;

        template<typename T>
        struct restore<T, T> {
            T operator()(T &&fref) { return std::forward<T>(fref); }
        };

        template<typename T>
        struct restore<T &, T *> {
            T &operator()(T *&&ptr) { return *ptr; }
        };

        /// \brief Checks if a type is not const
        /// \tparam T Type to check
        template<typename T>
        struct is_not_void : public std::negation<std::is_void<T>> {};

        /// \brief Checks if a type is not const
        /// \tparam T Type to check
        template<typename T>
        constexpr bool is_not_void_v = is_not_void<T>::value;

    }// namespace typing

    namespace reflection {

        /// \brief Enumerates identifiers for reflective symbols
        typedef enum : std::uint8_t {
            SYMBOL_CONSTRUCTOR = 1u << 0u,///<Describes a constructor
            SYMBOL_DESTRUCTOR = 1u << 1u, ///<Describes a destructor
            SYMBOL_FUNCTION = 1u << 2u,   ///<Describes a member function
            SYMBOL_PROPERTY = 1u << 3u,   ///<Describes a member variable
            SYMBOL_CONST = 1u << 4u,      ///<Describes a const symbol
            SYMBOL_STATIC = 1u << 5u,     ///<Describes a static symbol
            SYMBOL_REFERENCE = 1u << 6u,  ///<Describes a reference
        } symbol_t;

        template<typename T>
        struct type_identity {
            using type = T;
        };

        using unique_t = OCEAD_REFLECTION_COUNTER_TYPE;

        using id_t = OCEAD_REFLECTION_ID_TYPE;

        using type_t = OCEAD_REFLECTION_TYPEID_TYPE;

        using name_t = OCEAD_REFLECTION_NAME_TYPE;

        using shared_ptr_t = OCEAD_REFLECTION_SHARED_PTR_TYPE;

        using accessor_t = void *(*) (void *);
        using const_accessor_t = void const *(*) (void const *);
        using invoker_t = void (*)(void *, void *, void *);
        using const_invoker_t = void (*)(void *, void const *, void *);
        using constructor_t = void *(*) (void *);
        using placement_constructor_t = void *(*) (void *, void *);
        using shared_constructor_t = shared_ptr_t (*)(void *);
        using destructor_t = void (*)(void *);
        using deleter_t = void (*)(void *&);

        template<typename... Args>
        using map_t = OCEAD_REFLECTION_REFLECTOR_MAP_TYPE<Args...>;

        /// \brief Describes a reflective symbol of a reflective class
        /// \ingroup reflector
        struct symbol_descriptor {
        public:
            /// \brief Helper struct for determining return types of functions
            /// \tparam RCTp Class type
            /// \tparam ID ID of a reflective symbol
            template<typename RCTp, id_t ID>
            struct return_type {
                using type =
                        typename RCTp::template OCEAD_REFLECTION_ADD_PREFIX(
                                type)<ID>::type;
                using pointer_type = typename std::add_pointer<type>::type;
                using const_pointer_type = typename std::add_pointer<
                        typename std::add_const<type>::type>::type;
                using lvalue_reference_type =
                        typename std::add_lvalue_reference<type>::type;
                using const_lvalue_reference_type =
                        typename std::remove_reference_t<
                                lvalue_reference_type> const &;
                using rvalue_reference_type =
                        typename std::add_rvalue_reference<type>::type;
            };

            unique_t unique;///<Program-wide unique ID
            symbol_t symbol;///<Symbol type
            id_t id;        ///<Class-wide unique ID
            type_t type;    ///<Type hash of the symbol
            name_t name;    ///<Name of the symbol

            /// \brief Addresses and offset relevant to the symbol
            union {
                /// \brief Address container for properties
                struct {
                    /// \brief Pointer to accessor function
                    accessor_t accessor;
                    /// \brief Pointer to const accessor function
                    const_accessor_t const_accessor;
                    /// \brief Computable offset
                    std::ptrdiff_t offset;
                };

                /// \brief Address container for functions
                struct {
                    /// \brief Pointer to invoker function
                    invoker_t invoker;
                    /// \brief Pointer to const invoker function
                    const_invoker_t const_invoker;
                };

                /// \brief Address container for constructor
                struct {
                    /// \brief Pointer to constructor function
                    constructor_t constructor;
                    /// \brief Pointer to placement constructor function
                    placement_constructor_t placement_constructor;
                    /// \brief Pointer to shared pointer constructor function
                    shared_constructor_t shared_constructor;
                };

                /// \brief Address container for destructor
                struct {
                    /// \brief Pointer to destructor function
                    destructor_t destructor;
                    /// \brief Pointer to deallocating destructor function
                    deleter_t deleter;
                };

                /// \brief Address container for raw addresses
                struct {
                    void *_1 = nullptr;
                    void *_2 = nullptr;
                    void *_3 = nullptr;
                };
            };

            /// \brief Constructs a symbol descriptor
            /// for a reflective property
            /// \param unique Program-wide unique ID
            /// \param symbol Symbol type
            /// \param id Class-wide ID
            /// \param type Property type
            /// \param name Property name
            /// \param accessor Accessor function
            /// \param const_accessor Const accessor function
            constexpr symbol_descriptor(unique_t unique, symbol_t symbol,
                                        id_t id, type_t type, name_t name,
                                        accessor_t accessor,
                                        const_accessor_t const_accessor)
                : unique(unique), symbol(symbol), id(id), type(type),
                  name(name), accessor(accessor),
                  const_accessor(const_accessor), offset() {}

            /// \brief Constructs a symbol descriptor
            /// for a reflective non-const member function
            /// \param unique Program-wide unique ID
            /// \param symbol Symbol type
            /// \param id Class-wide ID
            /// \param type Function return type
            /// \param name Function name
            /// \param invoker Invoker function
            constexpr symbol_descriptor(unique_t unique, symbol_t symbol,
                                        id_t id, type_t type, name_t name,
                                        invoker_t invoker)
                : unique(unique), symbol(symbol), id(id), type(type),
                  name(name), invoker(invoker), const_invoker(nullptr) {}

            /// \brief Constructs a symbol descriptor
            /// for a reflective non-const member function
            /// \param unique Program-wide unique ID
            /// \param symbol Symbol type
            /// \param id Class-wide ID
            /// \param type Function return type
            /// \param name Function name
            /// \param const_invoker Const invoker function
            constexpr symbol_descriptor(unique_t unique, symbol_t symbol,
                                        id_t id, type_t type, name_t name,
                                        const_invoker_t const_invoker)
                : unique(unique), symbol(symbol), id(id), type(type),
                  name(name), invoker(nullptr), const_invoker(const_invoker) {}

            /// \brief Constructs a symbol descriptor
            /// for a reflective constructor
            /// \param unique Program-wide unique ID
            /// \param symbol Symbol type
            /// \param id Class-wide ID
            /// \param type Class type
            /// \param name Class name
            /// \param constructor New constructor function
            /// \param placement_constructor Placement new constructor function
            /// \param shared_constructor Shared pointer constructor function
            constexpr symbol_descriptor(
                    unique_t unique, symbol_t symbol, id_t id, type_t type,
                    name_t name, constructor_t constructor,
                    placement_constructor_t placement_constructor,
                    shared_constructor_t shared_constructor)
                : unique(unique), symbol(symbol), id(id), type(type),
                  name(name), constructor(constructor),
                  placement_constructor(placement_constructor),
                  shared_constructor(shared_constructor) {}

            /// \brief Constructs a symbol descriptor
            /// for a reflective destructor
            /// \param unique Program-wide unique ID
            /// \param symbol Symbol type
            /// \param id Class-wide ID
            /// \param type Class type
            /// \param name Class name
            /// \param destructor Destructor function
            /// \param deleter Deallocating destructor function
            constexpr symbol_descriptor(unique_t unique, symbol_t symbol,
                                        id_t id, type_t type, name_t name,
                                        destructor_t destructor,
                                        deleter_t deleter)
                : unique(unique), symbol(symbol), id(id), type(type),
                  name(name), destructor(destructor), deleter(deleter) {}

            /// \brief Accesses a typed reflective member variable
            /// \tparam ID ID of the reflective member variable
            /// \tparam RCTp Reflective class type
            /// \param obj Object, which's member should be accessed
            /// \return A reference to the member variable of <code>obj</code>
            template<id_t ID, typename RCTp>
            [[nodiscard]] auto access(RCTp &obj) const ->
                    typename return_type<RCTp, ID>::lvalue_reference_type {
                using RTp = typename return_type<RCTp, ID>::type;
                using PRTp = typename std::remove_reference<RTp>::type;
                return *static_cast<PRTp *>(access(&obj));
            }

            /// \brief Accesses a typed reflective member variable
            /// \tparam ID ID of the reflective member variable
            /// \tparam RCTp Reflective class type
            /// \param obj Object, which's member should be accessed
            /// \return A reference to the member variable of <code>obj</code>
            template<id_t ID, typename RCTp>
            [[nodiscard]] auto access(RCTp const &obj) const ->
                    typename return_type<RCTp,
                                         ID>::const_lvalue_reference_type {
                using RTp = typename return_type<RCTp, ID>::type;
                using PRTp = typename std::remove_reference<RTp>::type;
                return *static_cast<PRTp *>(const_access(&obj));
            }

            /// \brief Accesses an untyped reflective member variable
            /// \param obj Object, which's member should be accessed
            /// \return A pointer to the member variable of <code>obj</code>
            [[nodiscard]] void *access(void *obj) const {
                assert(symbol & ocead::reflection::symbol_t::SYMBOL_PROPERTY);
                assert(accessor != nullptr);
                return accessor(obj);
            }

            // \brief Accesses an untyped reflective member variable
            /// \param obj Object, which's member should be accessed
            /// \return A pointer to the member variable of <code>obj</code>
            [[nodiscard]] void const *access(void const *obj) const {
                assert(symbol & ocead::reflection::symbol_t::SYMBOL_PROPERTY);
                assert(const_accessor != nullptr);
                return const_accessor(obj);
            }

            /// \brief Accesses a typed reflective member variable by offset
            /// \tparam ID ID of the reflective member variable
            /// \tparam RCTp Reflective class type
            /// \param obj Object, which's member should be accessed
            /// \return A reference to the member variable of <code>obj</code>
            template<id_t ID, typename RCTp>
            [[nodiscard]] inline auto offset_access(RCTp &obj) const ->
                    typename return_type<RCTp, ID>::lvalue_reference_type {
                using RTp = typename return_type<RCTp, ID>::type;
                using PRTp = typename std::remove_reference<RTp>::type;
                static_assert(!std::is_reference_v<RTp>,
                              "References can not be accessed by offset!");
                return *reinterpret_cast<PRTp *>(
                        reinterpret_cast<std::byte *>(&obj) + offset);
            }

            /// \brief Accesses a typed reflective member variable by offset
            /// \tparam ID ID of the reflective member variable
            /// \tparam RCTp Reflective class type
            /// \param obj Object, which's member should be accessed
            /// \return A reference to the member variable of <code>obj</code>
            template<id_t ID, typename RCTp>
            [[nodiscard]] inline auto offset_access(RCTp const &obj) const ->
                    typename return_type<RCTp,
                                         ID>::const_lvalue_reference_type {
                using RTp = typename return_type<RCTp, ID>::type;
                using PRTp = typename std::remove_reference<RTp>::type;
                static_assert(!std::is_reference_v<RTp>,
                              "References can not be accessed by offset!");
                return *reinterpret_cast<PRTp *>(
                        reinterpret_cast<std::byte *>(&obj) + offset);
            }

            // \brief Accesses an untyped reflective member variable by offset
            /// \param obj Object, which's member should be accessed
            /// \return A pointer to the member variable of <code>obj</code>
            [[nodiscard]] inline void *offset_access(std::byte *obj) const {
                assert(symbol & ocead::reflection::symbol_t::SYMBOL_PROPERTY);
                assert(!(symbol &
                         ocead::reflection::symbol_t::SYMBOL_REFERENCE));
                return obj + offset;
            }

            /// \brief Accesses an untyped reflective member variable by offset
            /// \param obj Object, which's member should be accessed
            /// \return A pointer to the member variable of <code>obj</code>
            [[nodiscard]] inline void const *
            offset_access(std::byte const *obj) const {
                assert(symbol & ocead::reflection::symbol_t::SYMBOL_PROPERTY);
                assert(!(symbol &
                         ocead::reflection::symbol_t::SYMBOL_REFERENCE));
                return obj + offset;
            }

            /// \brief Accesses a typed reflective member variable
            /// \tparam ID ID of the reflective member variable
            /// \tparam RCTp Reflective class type
            /// \param obj Object, which's member should be accessed
            /// \return A reference to the member variable of <code>obj</code>
            template<id_t ID, typename RCTp>
            [[nodiscard]] auto const_access(RCTp const &obj) const ->
                    typename return_type<RCTp,
                                         ID>::const_lvalue_reference_type {
                using RTp = typename return_type<RCTp, ID>::type;
                using PRTp = typename std::remove_reference<RTp>::type;
                return *static_cast<PRTp const *>(const_access(&obj));
            }

            /// \brief Accesses an untyped reflective member variable
            /// \param obj Object, which's member should be accessed
            /// \return A pointer to the member variable of <code>obj</code>
            [[nodiscard]] void const *const_access(void const *obj) const {
                assert(symbol & ocead::reflection::symbol_t::SYMBOL_PROPERTY);
                assert(const_accessor != nullptr);
                return const_accessor(obj);
            }

            /// \brief Accesses a typed reflective member variable by offset
            /// \tparam ID ID of the reflective member variable
            /// \tparam RCTp Reflective class type
            /// \param obj Object, which's member should be accessed
            /// \return A reference to the member variable of <code>obj</code>
            template<id_t ID, typename RCTp>
            [[nodiscard]] inline auto const_offset_access(RCTp const &obj) const
                    -> typename return_type<RCTp,
                                            ID>::const_lvalue_reference_type {
                using RTp = typename return_type<RCTp, ID>::type;
                using PRTp = typename std::remove_reference<RTp>::type;
                static_assert(!std::is_reference_v<RTp>,
                              "References can not be accessed by offset!");
                return *reinterpret_cast<PRTp const *>(
                        reinterpret_cast<std::byte *>(&obj) + offset);
            }

            /// \brief Accesses an untyped reflective member variable by offset
            /// \param obj Object, which's member should be accessed
            /// \return A pointer to the member variable of <code>obj</code>
            [[nodiscard]] inline void const *
            const_offset_access(std::byte const *obj) const {
                assert(symbol & ocead::reflection::symbol_t::SYMBOL_PROPERTY);
                assert(!(symbol &
                         ocead::reflection::symbol_t::SYMBOL_REFERENCE));
                return obj + offset;
            }

            /// \brief Invokes a typed reflective member function
            /// \tparam RTp Expected return type
            /// \tparam ID ID of the reflective member function
            /// \tparam RCTp Reflective class type
            /// \tparam ArgsTps Argument types
            /// \param obj Object, on which the function shall be invoked
            /// \param args Arguments for the invocation
            /// \return Return value of the reflective member function
            template<typename RTp, typename RCTp, typename... ArgsTps>
            RTp invoke(RCTp *obj, ArgsTps &&...args) const {
                using PRTp = typename ocead::typing::simplify<RTp>::type;
                alignas(PRTp) std::byte buffer[sizeof(PRTp)];
                PRTp &ret = *reinterpret_cast<PRTp *>(buffer);
                if (std::is_const_v<RCTp> ||
                    symbol & ocead::reflection::symbol_t::SYMBOL_CONST) {
                    const_invoke(&ret, (void const *) obj,
                                 std::forward<ArgsTps>(args)...);
                } else {
                    invoke(&ret, obj, std::forward<ArgsTps>(args)...);
                }
                return ocead::typing::restore<RTp, PRTp>()(std::move(ret));
            }

            /// \brief Invokes a typed reflective member function
            /// \tparam ID ID of the reflective member function
            /// \tparam RCTp Reflective class type
            /// \tparam ArgsTps Argument types
            /// \param obj Object, on which the function shall be invoked
            /// \param args Arguments for the invocation
            /// \return Return value of the reflective member function
            template<id_t ID, typename RCTp, typename... ArgsTps>
            auto invoke(RCTp &obj, ArgsTps &&...args) const ->
                    typename return_type<RCTp, ID>::type {
                using RTp = typename return_type<RCTp, ID>::type;
                return invoke<RTp>(&obj, std::forward<ArgsTps>(args)...);
            }

            /// \brief Invokes an untyped reflective member function
            /// \tparam ArgsTps Argument types
            /// \param [out] ret Target of the invocations return value
            /// \param obj Object, on which the function shall be invoked
            /// \param args Arguments for the invocation
            template<typename... ArgsTps>
            void invoke(void *ret, void *obj, ArgsTps &&...args) const {
                assert(symbol & ocead::reflection::symbol_t::SYMBOL_FUNCTION);
                assert(invoker != nullptr);
                auto argstpl = std::make_tuple(std::forward<ArgsTps>(args)...);
                invoker(ret, obj, &argstpl);
            }

            /// \brief Invokes an untyped reflective member function
            /// \tparam ArgsTps Argument types
            /// \param [out] ret Target of the invocations return value
            /// \param obj Object, on which the function shall be invoked
            /// \param args Arguments for the invocation
            template<typename... ArgsTps>
            void invoke(void *ret, void const *obj, ArgsTps &&...args) const {
                const_invoke(ret, obj, std::forward<ArgsTps>(args)...);
            }

            /// \brief Invokes an untyped reflective member function
            /// \tparam ArgsTps Argument types
            /// \param [out] ret Target of the invocations return value
            /// \param obj Object, on which the function shall be invoked
            /// \param args Arguments for the invocation
            template<typename... ArgsTps>
            void const_invoke(void *ret, void const *obj,
                              ArgsTps &&...args) const {
                assert(symbol & ocead::reflection::symbol_t::SYMBOL_FUNCTION);
                assert(const_invoker != nullptr);
                auto argstpl = std::make_tuple(std::forward<ArgsTps>(args)...);
                const_invoker(ret, obj, &argstpl);
            }

            /// \brief Constructs an instance of a reflective class
            /// \tparam ArgsTps Argument types
            /// \param args Arguments for the invocation
            /// \return Pointer to the constructed object
            template<typename... ArgsTps>
            [[nodiscard]] void *construct(ArgsTps &&...args) const {
                assert(symbol &
                       ocead::reflection::symbol_t::SYMBOL_CONSTRUCTOR);
                assert(constructor != nullptr);
                auto argstpl = std::make_tuple(std::forward<ArgsTps>(args)...);
                return constructor(&argstpl);
            }

            /// \brief Constructs an instance of a reflective class
            /// at the specified address
            /// \tparam ArgsTps Argument types
            /// \param [out] ptr Target address for the constructor
            /// \param args Arguments for the invocation
            /// \return Pointer to the constructed object
            template<typename... ArgsTps>
            void *placement_construct(void *ptr, ArgsTps &&...args) const {
                assert(symbol &
                       ocead::reflection::symbol_t::SYMBOL_CONSTRUCTOR);
                assert(placement_constructor != nullptr);
                auto argstpl = std::make_tuple(std::forward<ArgsTps>(args)...);
                return placement_constructor(ptr, &argstpl);
            }

            /// \brief Constructs an instance of a reflective class
            /// \tparam ArgsTps Argument types
            /// \param args Arguments for the invocation
            /// \return A shared pointer to the created object
            template<typename... ArgsTps>
            [[nodiscard]] shared_ptr_t
            shared_construct(ArgsTps &&...args) const {
                assert(symbol &
                       ocead::reflection::symbol_t::SYMBOL_CONSTRUCTOR);
                assert(shared_constructor != nullptr);
                auto argstpl = std::make_tuple(std::forward<ArgsTps>(args)...);
                return shared_constructor(&argstpl);
            }

            /// \brief Calls the destructor for a reflective object
            /// \param ptr Pointer to a reflective object
            void destroy(void *ptr) const {
                assert(symbol & ocead::reflection::symbol_t::SYMBOL_DESTRUCTOR);
                assert(destructor != nullptr);
                return destructor(ptr);
            }

            /// \brief Calls the destructor for, and deallocates a reflective object
            /// \param ptr Pointer to a reflective object
            void dealloc_destroy(void *&ptr) const {
                assert(symbol & ocead::reflection::symbol_t::SYMBOL_DESTRUCTOR);
                assert(deleter != nullptr);
                return deleter(ptr);
            }

            /// \brief Copy constructor
            symbol_descriptor(symbol_descriptor const &) = default;

            /// \brief Move constructor
            symbol_descriptor(symbol_descriptor &&) noexcept = default;

            /// \brief Copy assignment
            /// \return The object assigned to
            symbol_descriptor &operator=(symbol_descriptor const &) = default;

            /// \brief Move assignment
            /// \return The object assigned to
            symbol_descriptor &
            operator=(symbol_descriptor &&) noexcept = default;

            /// \brief Default destructor
            ~symbol_descriptor() noexcept = default;
        };

        class reflective;

        /// \brief Describes a reflective class
        /// \ingroup reflector
        class class_descriptor : private map_t<id_t, symbol_descriptor> {
        private:
            using Map = map_t<id_t, symbol_descriptor>;

            /// \brief Iterator over reflective symbols of a reflective class
            /// \tparam I Increment ID
            template<unique_t I>
            struct property_iterator {
                /// \brief Emplaces a <code>symbol_descriptor</code>
                /// into a <code>class_descriptor</code>
                /// \tparam RCTp Reflective class type
                /// \param refl The <code>class_descriptor</code>
                template<typename RCTp>
                inline void operator()(RCTp *, class_descriptor &refl) {
                    auto desc = RCTp::template OCEAD_REFLECTION_ADD_PREFIX(
                            symbol_descriptor)<I, void>::value;
                    refl.emplace(std::make_pair(desc.id, desc));
                }
            };

            std::size_t size{}; ///<Size of the described reflective class
            std::size_t align{};///<Alignment of the described reflective class

            class_descriptor() = default;

        public:
            /// \brief Constructs a descriptor for a given type
            /// \tparam RCTp Reflective class type
            /// \return The constructed <code>class_descriptor</code>
            template<typename RCTp>
            [[nodiscard]] static class_descriptor reflect() {
                return class_descriptor(static_cast<RCTp const *>(nullptr));
            }

            /// \brief Constructs a descriptor for a given type
            /// \tparam RCTp Reflective class type
            template<typename RCTp>
            explicit class_descriptor(RCTp const *)
                : size(sizeof(RCTp)), align(alignof(RCTp)) {
                ocead::static_for<OCEAD_REFLECTION_COUNTER_TYPE,
                                  RCTp::OCEAD_REFLECTION_ADD_PREFIX(BEGIN_ID),
                                  RCTp::OCEAD_REFLECTION_ADD_PREFIX(END_ID),
                                  property_iterator>(
                        static_cast<RCTp *>(nullptr), std::ref(*this));
                for (auto &[id, symbol] : static_cast<Map &>(*this)) {
                    if (symbol.symbol & SYMBOL_PROPERTY) {
                        if (!(symbol.symbol & SYMBOL_REFERENCE)) {
                            symbol.offset =
                                    (std::ptrdiff_t)(static_cast<std::byte *>(
                                            symbol.access((void *) nullptr)));
                        } else {
                            symbol.offset =
                                    std::numeric_limits<std::ptrdiff_t>::max();
                        }
                    }
                }
            }

            /// \brief Copy constructor
            class_descriptor(class_descriptor const &) = default;

            /// \brief Move constructor
            class_descriptor(class_descriptor &&) noexcept = default;

            /// \brief Returns the described classes size in bytes
            /// \return The described classes size in bytes
            [[nodiscard]] std::size_t class_size() const { return size; }

            /// \brief Returns the described classes alignment in bytes
            /// \return The described classes alignment in bytes
            [[nodiscard]] std::size_t class_align() const { return align; }

            [[nodiscard]] symbol_descriptor const &symbol(id_t id) const {
                return at(id);
            }

            [[nodiscard]] Map::const_iterator begin() const noexcept {
                return Map::cbegin();
            }

            [[nodiscard]] Map::const_iterator cbegin() const noexcept {
                return Map::cbegin();
            }

            [[nodiscard]] Map::const_iterator end() const noexcept {
                return Map::cend();
            }

            [[nodiscard]] Map::const_iterator cend() const noexcept {
                return Map::cend();
            }

            /// \brief Accesses a typed reflective member variable
            /// \tparam ID ID of the reflective member variable
            /// \tparam RCTp Reflective class type
            /// \param obj Object, which's member should be accessed
            /// \return A reference to the member variable of <code>obj</code>
            template<id_t ID, typename RCTp>
            [[nodiscard]] auto access(RCTp &obj) const ->
                    typename symbol_descriptor::return_type<
                            RCTp, ID>::lvalue_reference_type {
                return at(ID).access<ID>(obj);
            }

            /// \brief Accesses a typed reflective member variable
            /// \tparam ID ID of the reflective member variable
            /// \tparam RCTp Reflective class type
            /// \param obj Object, which's member should be accessed
            /// \return A reference to the member variable of <code>obj</code>
            template<id_t ID, typename RCTp>
            [[nodiscard]] auto access(RCTp const &obj) const ->
                    typename symbol_descriptor::return_type<
                            RCTp, ID>::const_lvalue_reference_type {
                return at(ID).const_access<ID>(obj);
            }

            /// \brief Accesses an untyped reflective member variable
            /// \param obj Object, which's member should be accessed
            /// \param id ID of the reflective member variable
            /// \return A pointer to the member variable of <code>obj</code>
            [[nodiscard]] void *access(void *obj, id_t id) const {
                return at(id).access(obj);
            }

            /// \brief Accesses an untyped reflective member variable
            /// \param obj Object, which's member should be accessed
            /// \param id ID of the reflective member variable
            /// \return A pointer to the member variable of <code>obj</code>
            [[nodiscard]] void const *access(void const *obj, id_t id) const {
                return at(id).const_access(obj);
            }

            /// \brief Accesses a typed reflective member variable by offset
            /// \tparam ID ID of the reflective member variable
            /// \tparam RCTp Reflective class type
            /// \param obj Object, which's member should be accessed
            /// \return A reference to the member variable of <code>obj</code>
            template<id_t ID, typename RCTp>
            [[nodiscard]] inline auto offset_access(RCTp &obj) const ->
                    typename symbol_descriptor::return_type<
                            RCTp, ID>::lvalue_reference_type {
                return at(ID).offset_access<ID>(obj);
            }

            /// \brief Accesses a typed reflective member variable by offset
            /// \tparam ID ID of the reflective member variable
            /// \tparam RCTp Reflective class type
            /// \param obj Object, which's member should be accessed
            /// \return A reference to the member variable of <code>obj</code>
            template<id_t ID, typename RCTp>
            [[nodiscard]] inline auto offset_access(RCTp const &obj) const ->
                    typename symbol_descriptor::return_type<
                            RCTp, ID>::const_lvalue_reference_type {
                return at(ID).const_offset_access<ID>(obj);
            }

            /// \brief Accesses an untyped reflective member variable by offset
            /// \param obj Object, which's member should be accessed
            /// \param id ID of the reflective member variable
            /// \return A pointer to the member variable of <code>obj</code>
            [[nodiscard]] inline void *offset_access(void *obj, id_t id) const {
                return at(id).offset_access(reinterpret_cast<std::byte *>(obj));
            }

            /// \brief Accesses an untyped reflective member variable by offset
            /// \param obj Object, which's member should be accessed
            /// \param id ID of the reflective member variable
            /// \return A pointer to the member variable of <code>obj</code>
            [[nodiscard]] inline void const *offset_access(void const *obj,
                                                           id_t id) const {
                return at(id).const_offset_access(
                        reinterpret_cast<std::byte const *>(obj));
            }

            /// \brief Accesses a typed reflective member variable
            /// \tparam ID ID of the reflective member variable
            /// \tparam RCTp Reflective class type
            /// \param obj Object, which's member should be accessed
            /// \return A reference to the member variable of <code>obj</code>
            template<id_t ID, typename RCTp>
            [[nodiscard]] auto const_access(RCTp const &obj) const ->
                    typename symbol_descriptor::return_type<
                            RCTp, ID>::const_lvalue_reference_type {
                return at(ID).const_access<ID>(obj);
            }

            /// \brief Accesses an untyped reflective member variable
            /// \param obj Object, which's member should be accessed
            /// \param id ID of the reflective member variable
            /// \return A pointer to the member variable of <code>obj</code>
            [[nodiscard]] void const *const_access(void const *obj,
                                                   id_t id) const {
                return at(id).const_access(obj);
            }

            /// \brief Accesses a typed reflective member variable by offset
            /// \tparam ID ID of the reflective member variable
            /// \tparam RCTp Reflective class type
            /// \param obj Object, which's member should be accessed
            /// \return A reference to the member variable of <code>obj</code>
            template<id_t ID, typename RCTp>
            [[nodiscard]] inline auto const_offset_access(RCTp const &obj) const
                    -> typename symbol_descriptor::return_type<
                            RCTp, ID>::const_lvalue_reference_type {
                return at(ID).const_offset_access<ID>(obj);
            }

            /// \brief Accesses an untyped reflective member variable by offset
            /// \param obj Object, which's member should be accessed
            /// \param id ID of the reflective member variable
            /// \return A pointer to the member variable of <code>obj</code>
            [[nodiscard]] inline void const *
            const_offset_access(void const *obj, id_t id) const {
                return at(id).const_offset_access(
                        reinterpret_cast<std::byte const *>(obj));
            }

            /// \brief Invokes a typed reflective member function
            /// \tparam ID ID of the reflective member function
            /// \tparam RCTp Reflective class type
            /// \tparam ArgsTps Argument types
            /// \param obj Object, on which the function shall be invoked
            /// \param args Arguments for the invocation
            /// \return Return value of the reflective member function
            template<id_t ID, typename RCTp, typename... ArgsTps>
            auto invoke(RCTp &obj, ArgsTps &&...args) const ->
                    typename symbol_descriptor::return_type<RCTp, ID>::type {
                return at(ID).invoke<ID>(obj, std::forward<ArgsTps>(args)...);
            }

            /// \brief Invokes a typed reflective member function
            /// \tparam RTp Expected return type
            /// \tparam ID ID of the reflective member function
            /// \tparam RCTp Reflective class type
            /// \tparam ArgsTps Argument types
            /// \param obj Object, on which the function shall be invoked
            /// \param args Arguments for the invocation
            /// \return Return value of the reflective member function
            template<typename RTp, id_t ID, typename RCTp, typename... ArgsTps>
            RTp invoke(RCTp &obj, ArgsTps &&...args) const {
                return at(ID).invoke<RTp, ID>(obj,
                                              std::forward<ArgsTps>(args)...);
            }

            /// \brief Invokes an untyped reflective member function
            /// \tparam ArgsTps Argument types
            /// \param obj Object, on which the function shall be invoked
            /// \param id ID of the reflective member function
            /// \param args Arguments for the invocation
            template<typename... ArgsTps>
            void invoke(void *obj, id_t id, ArgsTps &&...args) const {
                at(id).invoke(nullptr, obj, std::forward<ArgsTps>(args)...);
            }

            /// \brief Invokes an untyped reflective member function
            /// \tparam ArgsTps Argument types
            /// \param obj Object, on which the function shall be invoked
            /// \param id ID of the reflective member function
            /// \param args Arguments for the invocation
            template<typename... ArgsTps>
            void invoke(void const *obj, id_t id, ArgsTps &&...args) const {
                at(id).const_invoke(nullptr, obj,
                                    std::forward<ArgsTps>(args)...);
            }

            /// \brief Invokes an untyped reflective member function
            /// \tparam RTp Expected return type
            /// \tparam ArgsTps Argument types
            /// \param obj Object, on which the function shall be invoked
            /// \param id ID of the reflective member function
            /// \param args Arguments for the invocation
            template<typename RTp, typename... ArgsTps>
            RTp invoke_return(void *obj, id_t id, ArgsTps &&...args) const {
                return at(id).invoke<RTp>(obj, std::forward<ArgsTps>(args)...);
            }

            /// \brief Invokes an untyped reflective member function
            /// \tparam RTp Expected return type
            /// \tparam ArgsTps Argument types
            /// \param obj Object, on which the function shall be invoked
            /// \param id ID of the reflective member function
            /// \param args Arguments for the invocation
            template<typename RTp, typename... ArgsTps>
            RTp invoke_return(void const *obj, id_t id,
                              ArgsTps &&...args) const {
                return at(id).invoke<RTp>(obj, std::forward<ArgsTps>(args)...);
            }

            /// \brief Invokes an untyped reflective member function
            /// \tparam RTp Expected return type
            /// \tparam ArgsTps Argument types
            /// \param obj Object, on which the function shall be invoked
            /// \param id ID of the reflective member function
            /// \param args Arguments for the invocation
            template<typename RTp, typename... ArgsTps>
            RTp const_invoke_return(void const *obj, id_t id,
                                    ArgsTps &&...args) const {
                return at(id).invoke<RTp>(obj, std::forward<ArgsTps>(args)...);
            }

            /// \brief Constructs an instance of a reflective class
            /// \tparam ID ID of the reflective constructor
            /// \tparam ArgsTps Argument types
            /// \param args Arguments for the invocation
            /// \return Pointer to the constructed object
            template<id_t ID, typename... ArgsTps>
            [[nodiscard]] void *construct(ArgsTps &&...args) const {
                return at(ID).construct(std::forward<ArgsTps>(args)...);
            }

            /// \brief Constructs an instance of a reflective class
            /// \tparam ArgsTps Argument types
            /// \param id ID of the reflective constructor
            /// \param args Arguments for the invocation
            /// \return Pointer to the constructed object
            template<typename... ArgsTps>
            [[nodiscard]] void *construct(id_t id, ArgsTps &&...args) const {
                return at(id).construct(std::forward<ArgsTps>(args)...);
            }

            /// \brief Constructs an instance of a reflective class
            /// at the specified address
            /// \tparam ID ID of the reflective constructor
            /// \tparam ArgsTps Argument types
            /// \param [out] ptr Target address for the constructor
            /// \param args Arguments for the invocation
            /// \return Pointer to the constructed object
            template<id_t ID, typename... ArgsTps>
            void *placement_construct(void *ptr, ArgsTps &&...args) const {
                return at(ID).placement_construct(
                        ptr, std::forward<ArgsTps>(args)...);
            }

            /// \brief Constructs an instance of a reflective class
            /// at the specified address
            /// \tparam ArgsTps Argument types
            /// \param [out] ptr Target address for the constructor
            /// \param id ID of the reflective constructor
            /// \param args Arguments for the invocation
            /// \return Pointer to the constructed object
            template<typename... ArgsTps>
            void *placement_construct(void *ptr, id_t id,
                                      ArgsTps &&...args) const {
                return at(id).placement_construct(
                        ptr, std::forward<ArgsTps>(args)...);
            }

            /// \brief Constructs an instance of a reflective class
            /// \tparam ID ID of the reflective constructor
            /// \tparam ArgsTps Argument types
            /// \param args Arguments for the invocation
            /// \return A shared pointer to the created object
            template<id_t ID, typename... ArgsTps>
            [[nodiscard]] shared_ptr_t
            shared_construct(ArgsTps &&...args) const {
                return at(ID).shared_construct(std::forward<ArgsTps>(args)...);
            }

            /// \brief Constructs an instance of a reflective class
            /// \tparam ArgsTps Argument types
            /// \param id ID of the reflective constructor
            /// \param args Arguments for the invocation
            /// \return A shared pointer to the created object
            template<typename... ArgsTps>
            [[nodiscard]] shared_ptr_t
            shared_construct(id_t id, ArgsTps &&...args) const {
                return at(id).shared_construct(std::forward<ArgsTps>(args)...);
            }

            /// \brief Calls the destructor for a reflective object
            /// \param id ID of the reflective destructor
            /// \param ptr Pointer to a reflective object
            void destroy(id_t id, void *ptr) const {
                return at(id).destroy(ptr);
            }

            /// \brief Calls the destructor for, and deallocates a reflective object
            /// \param id ID of the reflective destructor
            /// \param ptr Pointer to a reflective object
            void dealloc_destroy(id_t id, void *&ptr) const {
                return at(id).dealloc_destroy(ptr);
            }

            /// \brief Copy assignment
            /// \return The object assigned to
            class_descriptor &operator=(class_descriptor const &) = default;

            /// Move assignment
            /// \return The object assigned to
            class_descriptor &operator=(class_descriptor &&) noexcept = default;

            /// \brief Default destructor
            ~class_descriptor() noexcept = default;

            friend class reflective;
        };

        /// \brief Obtains a <code>class_descriptor</code>
        /// for a reflective class type
        /// \tparam RCTp Reflective class type
        /// \return The <code>class_descriptor</code>
        /// for a reflective class type
        /// \ingroup reflector
        template<typename RCTp>
        class_descriptor const &reflect() {
            return RCTp::OCEAD_REFLECTION_ADD_PREFIX(class_descriptor)();
        }


        /// \brief Interface for reflective classes
        /// \ingroup reflection
        class reflective {
#ifdef __cpp_rtti
        public:
            /// \brief Obtains a <code>class_descriptor</code>
            /// for a reflective class type
            /// \return The <code>class_descriptor</code>
            /// for a reflective class type
            ///
            /// \note This function is only present
            /// if <code>__cpp_rtti</code> is enabled
            [[nodiscard]] virtual class_descriptor const &reflect() const {
                static class_descriptor refl{};
                return refl;
            }
#endif
        };

    }// namespace reflection

    using reflection::reflective;

    using reflection::reflect;

}// namespace ocead

/// \brief Writes a symbol type into an output stream
/// \param os An output stream
/// \param s A symbol type
/// \return The output stream
/// \ingroup reflector
std::ostream &operator<<(std::ostream &os, ocead::reflection::symbol_t s) {
    if (s & ocead::reflection::symbol_t::SYMBOL_STATIC) { os << "s "; }
    if (s & ocead::reflection::symbol_t::SYMBOL_CONST) { os << "c "; }
    if (s & ocead::reflection::symbol_t::SYMBOL_PROPERTY) {
        os << "prop";
    } else if (s & ocead::reflection::symbol_t::SYMBOL_FUNCTION) {
        os << "func";
    } else if (s & ocead::reflection::symbol_t::SYMBOL_CONSTRUCTOR) {
        os << "ctor";
    } else if (s & ocead::reflection::symbol_t::SYMBOL_DESTRUCTOR) {
        os << "dtor";
    }
    return os;
}

/// \brief Writes a symbol descriptor into an output stream
/// \param os An output stream
/// \param sd A symbol descriptor
/// \return The output stream
/// \ingroup reflector
std::ostream &operator<<(std::ostream &os,
                         ocead::reflection::symbol_descriptor const &sd) {
    return os << sd.unique << ' ' << ocead::underlying(sd.id) << ' '
              << sd.symbol << ' ' << sd.type << ' ' << sd.name << ' ' << sd._1
              << ' ' << sd._2 << ' ' << sd._3;
}

//endregion

//region Records

#ifndef OCEAD_REFLECTION_RECORD_HPP
#define OCEAD_REFLECTION_RECORD_HPP

namespace ocead {

    namespace reflection {

        template<typename RCTp, reflection::id_t... IDs>
        struct record;

        /// \brief A record of a single class member variable
        /// \tparam RCTp Reflective class type
        /// \tparam ID ID of the reflective member variable
        /// \ingroup record
        template<typename RCTp, reflection::id_t ID>
        struct record_piece {
        public:
            static_assert(
                    std::is_base_of_v<ocead::reflection::reflective, RCTp>);
            static constexpr reflection::id_t id = ID;
            using class_type = RCTp;
            using qualified_type =
                    typename RCTp::template OCEAD_REFLECTION_ADD_PREFIX(
                            type)<ID, void>::type;
            using type = std::remove_cv_t<qualified_type>;

        private:
            type data;///<The contained record data

        public:
            /// \brief Constructs a record from an object
            /// \param orig Original object
            explicit constexpr record_piece(RCTp const &orig)
                : data(orig.template OCEAD_REFLECTION_ADD_PREFIX(
                               static_access) < ID > ()) {}

            template<typename CTp, ocead::reflection::id_t... IDs>
            friend struct record;
        };

        /// \brief A record type of a reflective class
        /// \tparam RCTp Reflective class type
        /// \tparam IDs IDs of member variables of <code>RCTp</code>
        /// \ingroup record
        template<typename RCTp, reflection::id_t... IDs>
        struct record : public record_piece<RCTp, IDs>... {
        public:
            /// \brief Constructs a record from an object
            /// \param original Original object
            explicit constexpr record(RCTp const &original)
                : record_piece<RCTp, IDs>(original)... {}

            /// \brief Copy constructor
            constexpr record(record const &) = default;

            /// \brief Move constructor
            constexpr record(record &&) noexcept = default;

            /// \brief Accesses a single recorded variable
            /// \tparam ID ID of the member variable of <code>RCTp</code>
            /// \return The recorded data
            template<ocead::reflection::id_t ID>
            [[nodiscard]] constexpr typename record_piece<RCTp, ID>::type &
            get() {
                return record_piece<RCTp, ID>::data;
            }

            /// \brief Accesses a single recorded variable
            /// \tparam ID ID of the member variable of <code>RCTp</code>
            /// \return The recorded data
            template<ocead::reflection::id_t ID>
            [[nodiscard]] constexpr const typename record_piece<RCTp, ID>::type
                    &
                    get() const {
                return record_piece<RCTp, ID>::data;
            }

            /// \brief Copy assignment
            /// \return The object assigned to
            constexpr record &operator=(record const &) = default;

            /// \brief Move assignment
            /// \return The object assigned to
            constexpr record &operator=(record &&) noexcept = default;

            /// \brief Default destructor
            ~record() noexcept = default;
        };

        /// \brief Creates a record
        /// containing certain properties of a reflective object
        /// \tparam IDs IDs of the properties that shall be contained
        /// \tparam RCTp A reflective class type
        /// \param ref An instance of the reflective class type
        /// \return The created record
        /// \ingroup record
        template<reflection::id_t... IDs, typename RCTp>
        constexpr auto make_record(RCTp const &ref) -> record<RCTp, IDs...> {
            return record<RCTp, IDs...>(ref);
        }
    }

    using reflection::make_record;
}// namespace ocead::reflection

namespace std {//NOLINT
    /// \brief Accesses a single recorded variable
    /// \tparam ID ID of the member variable of <code>RCTp</code>
    /// \tparam RCTp A reflective class type
    /// \tparam IDs The IDs of the record's contained properties
    /// \param record The record to access
    /// \return A reference to the contained value
    template<ocead::reflection::id_t ID, typename RCTp,
             ocead::reflection::id_t... IDs>
    [[nodiscard]] constexpr
            typename ocead::reflection::record_piece<RCTp, ID>::type &
            get(ocead::reflection::record<RCTp, IDs...> &record) {
        return record.template get<ID>();
    }

    /// \brief Accesses a single recorded variable
    /// \tparam ID ID of the member variable of <code>RCTp</code>
    /// \tparam RCTp A reflective class type
    /// \tparam IDs The IDs of the record's contained properties
    /// \param record The record to access
    /// \return A reference to the contained value
    template<ocead::reflection::id_t ID, typename RCTp,
             ocead::reflection::id_t... IDs>
    [[nodiscard]] constexpr
            typename ocead::reflection::record_piece<RCTp, ID>::type const &
            get(ocead::reflection::record<RCTp, IDs...> const &record) {
        return record.template get<ID>();
    }
}// namespace std

#endif//OCEAD_REFLECTION_RECORD_HPP

//endregion

//region Convenience macros
#if !defined(BEGIN_REFLECTIVE) && !defined(PROP) && !defined(FUNC) &&          \
        !defined(CTOR) && !defined(DTOR) && !defined(END_REFLECTIVE)

/// \brief Opens a block of reflective symbols in a reflective class
/// \param class_name The name of the reflective class. <br/>
///        Declaration: \" <i>class-name</i> \"
/// \ingroup reflection
#define BEGIN_REFLECTIVE(class_name)                                           \
    OCEAD_REFLECTION_BEGIN_REFLECTIVE(class_name)

/// \brief Declares a reflective member variable
/// \param pre_symbol <small>(opt)</small> The access specifier and attributes
///        for the reflective member variable. <br/>
///        Declarations: \" <i>access-specifier</i> :
///        <i>attribute-specifier-seq</i><small>(opt)</small> \" <br/>
///        Default: \" <code>private:</code> \"
/// \param type The type of the reflective member variable. <br/>
///        Declarations: \" <i>defining-type-specifier</i> \"
/// \param id A constant expression of type
///        <code>OCEAD_REFLECTION_ID_TYPE</code>, that is unique
///        for all reflective symbols of the reflective class. <br/>
///        Declarations: \" <i>constant-expression</i> \"
/// \param name The name of the reflective member variable. <br/>
///        Declarations: \" <i>identifier</i> \"
///
/// This macro must be followed by with
/// \" <i>brace-or-equal-initializer</i><small>(opt)</small> ; \"
/// \ingroup reflection
#define PROP(...) OCEAD_REFLECTION_PROPERTY(__VA_ARGS__, __COUNTER__)

/// \brief Declares a reflective member function
/// \param pre_symbol <small>(opt)</small> The access specifier and attributes
///        for the reflective member function. <br/>
///        Declarations: \" <i>access-specifier</i> :
///        <i>attribute-specifier-seq</i><small>(opt)</small> \" <br/>
///        Default: \" <code>public:</code> \"
/// \param type The return type of the reflective member function. <br/>
///        Declarations: \" <i>defining-type-specifier</i> \"
/// \param id A constant expression of type
///        <code>OCEAD_REFLECTION_ID_TYPE</code>, that is unique
///        for all reflective symbols of the reflective class. <br/>
///        Declarations: \" <i>constant-expression</i> \"
/// \param name The name of the reflective member function. <br/>
///        Declarations: \" <i>identifier</i> \"
/// \param sig The function parameters and optional qualifiers
///        of the reflective member function. <br/>
///        Declarations:
///        \" ( <i>parameter-declaration-list</i><small>(opt)</small> )
///        <i>cv-qualifier-seq</i><small>(opt)</small> \"
///
/// This macro must be followed by with
/// \" <i>function-body</i><small>(opt)</small> \"
/// \ingroup reflection
#define FUNC(...) OCEAD_REFLECTION_FUNCTION(__VA_ARGS__, __COUNTER__)

/// \brief Declares a reflective constructor
/// \param pre_symbol <small>(opt)</small> The access specifier and attributes
///        for the reflective constructor. <br/>
///        Declarations: \" <i>access-specifier</i> :
///        <i>attribute-specifier-seq</i><small>(opt)</small>
///        <i>explicit-specifier</i><small>(opt)</small> \" <br/>
///        Default: \" <code>public:</code> \"
/// \param id A constant expression of type
///        <code>OCEAD_REFLECTION_ID_TYPE</code>, that is unique
///        for all reflective symbols of the reflective class. <br/>
///        Declarations: \" <i>constant-expression</i> \"
/// \param name The name of the reflective class. <br/>
///        Declarations: \" <i>class-name</i> \"
/// \param sig The function parameters and optional qualifiers
///        of the reflective constructor. <br/>
///        Declarations:
///        \" ( <i>parameter-declaration-list</i><small>(opt)</small> )
///        <i>noexcept-specifier</i><small>(opt)</small> \"
///
/// This macro must be followed by with
/// \" <i>function-body</i><small>(opt)</small> \"
/// \ingroup reflection
#define CTOR(...) OCEAD_REFLECTION_CONSTRUCTOR(__VA_ARGS__, __COUNTER__)

/// \brief Declares a reflective destructor
/// \param pre_symbol <small>(opt)</small> The access specifier and attributes
///        for the reflective destructor. <br/>
///        Declarations: \" <i>access-specifier</i> :
///        <i>attribute-specifier-seq</i><small>(opt)</small>
///        <i>explicit-specifier</i><small>(opt)</small> \" <br/>
///        Default: \" <code>public:</code> \"
/// \param id A constant expression of type
///        <code>OCEAD_REFLECTION_ID_TYPE</code>, that is unique
///        for all reflective symbols of the reflective class. <br/>
///        Declarations: \" <i>constant-expression</i> \"
/// \param name The name of the reflective class. <br/>
///        Declarations: \" <i>class-name</i> \"
///
/// This macro must be followed by with
/// \" <i>function-body</i><small>(opt)</small> \"
/// \ingroup reflection
#define DTOR(...) OCEAD_REFLECTION_DESTRUCTOR(__VA_ARGS__, __COUNTER__)

/// \brief Closes a block of reflective symbols in a reflective class
/// \ingroup reflection
#define END_REFLECTIVE() OCEAD_REFLECTION_END_REFLECTIVE()
#endif

#define OCEAD_REFLECTION_BODY(...)                                             \
    __VA_ARGS__                                                                \
    END_REFLECTIVE()

/// \brief Macro for declaring the reflective symbols of a reflective class
/// in a single macro expansion
/// \param class_name The name of the reflective class. <br/>
///        Declarations: \" <i>class-name</i> \"
/// \ingroup reflection
#define REFLECTIVE(class_name)                                                 \
    BEGIN_REFLECTIVE(class_name);                                              \
    OCEAD_REFLECTION_BODY

//endregion

#endif//OCEAD_REFLECTION_HPP
